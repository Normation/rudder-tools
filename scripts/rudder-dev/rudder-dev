#!/usr/bin/env python

"""
Rudder development tool.

You need a configuration file, if you don't have one, the tool will create one for you at first run.

Usage:
    rudder-dev -h|--help
    rudder-dev [-f|--force] clone <repository> [--fork]
    rudder-dev [-f|--force] pull [<branch>]
    rudder-dev [-f|--force] branch <ticket_id> [--base=<ticket_id>]
    rudder-dev [-f|--force] technique <version> <comment>
    rudder-dev [-f|--force] wip
    rudder-dev [-f|--force] commit [<trigraph> [<PR_comment>]]
    rudder-dev [-f|--force] amend [<PR_comment>]
    rudder-dev [-f|--force] rebase [--base=<ticket_id>] [<PR_comment>]
    rudder-dev [-f|--force] retarget [<target_version>]
    rudder-dev [-f|--force] takeover <ticket_id>
    rudder-dev [-f|--force] merge all [-s <strategy>] [-a|--automatic]
    rudder-dev [-f|--force] merge <first_branch> [-s <strategy>] [-a|--automatic]
    rudder-dev [-f|--force] merge <first_branch> <next_branch> [-s <strategy>] [-a|--automatic]
    rudder-dev [-f|--force] find <command>
    rudder-dev [-f|--force] cleanup [--more] [-n|--dry-run]
    rudder-dev [-f|--force] <smart_arg> [<PR_message>] [--base=<ticket_id>]

SMART
    <smart_arg> is a shortcut for other commands
    - if it is a number > 100, it is guessed to be a ticket_id -> branch
    - if it is a x.y or master, it is guessed to be a branch -> pull
    - if it is a caps TLA, it is guessed to be a trigraph -> commit

CLONE
    Call it when you want to work on a new repository.
    - fork the repository from Normation if --fork is given
    - clone it
    - setup both remote repository in git
    ex: rudder-dev clone rudder-techniques
    
PULL
    Call it to make sure you are on a branch and up to date
    - create the branch with remote tracking if it doesn't exist
    - checkout the branch if specified
    - update the current branch
    ex: rudder-dev pull 3.0
    ex: rudder-dev pull master

BRANCH
    Call it before working on a bug.
    - if the branch already exist, just checkout it
    - find and check the ticket from redmine
    - create a branch with the proper name in your repository
    - set the ticket status to "in progress"
    - if --base is given, use the PR from the base ticket as the origin branch
    - --base can also be a local branch name
    ex: rudder-dev branch 1234
    ex: rudder-dev branch '#1234' --base 1233

TECHNIQUE
    Call it after branching and before working on a new technique version.
    You must be in the technique directory containing all technique versions.
    - create a new version of a technique based on the last known version
    - add the comment to the changelog
    - create a commit for this new version
    ex: cd techniques/applications/apacheServer
        rudder-dev technique 4.0 "Add a new option"

WIP
    Commit a work in progress to keep it for later
    Later call to rudder-dev commit will merge wip with the final commit
    - commit with a sample "Work in progress" message
    - push on matching branch on own repository
    ex: rudder-dev wip

COMMIT
    Call it after working on a branch.
    - fork the repository if it has not yet been forked
    - commit current work (no -a, you need to git add)
    - push the branch to your github repository
    - make a pull-request to Normation's repository
    - update the coresponding bug with those informations
    ex: rudder-dev commit BPF "@reviewer please tell me it's good"
    ex: rudder-dev commit

AMEND
    Call it after you made a change to a branch with a PR.
    - commit current work amending last commit (no -a, you need to git add)
    - push the branch to your github repository
    - add a comment to the PR to signal the change
    ex: rudder-dev amend "@reviewer pr updated"

REBASE
    - interactive rebase on NRM branch
    - if rebase has worked, push to OWN
    - add a comment to the PR to signal the change
    - if --base is given, use the PR from the base ticket as the origin branch
    - --base can also be a local branch name
    ex: rudder-dev rebase "@reviewer pr updated"
    ex: rudder-dev rebase --base 1234

RETARGET
    - if a version is provided, update the ticket with it
    - if the ticket's version has changed, continue
    - rebase to ticket's NRM branch
    - close current PR
    - create new PR
    - update ticket
    ex: rudder-dev retarget

TAKEOVER
    - if the ticket has no pull-request, abandon
    - checkout upstream branch into local repository
    - rename it if needed
    - update the ticket's status
    ex: rudder-dev takeover 1234

MERGE (needs commit rights)
    Call it when you want to merge manually.
    "merge all" and "merge <first_branch>" are only valid within Rudder versioned repositories
    - checkout an pull last version
    - checkout an pull new version
    - merge both
    - push result to Normation's repository
    If the merge fail, please make adjustments, commit and rerun this command
    ex: rudder-dev merge 3.0 master

FIND (find the first version a command works)
    - for each branch version
    - checkout branch
    - run command
    - find when it returns 0
    ex: rudder-dev find 'grep bugfix path/file.cf'

CLEANUP (cleanup your repository
    - for each branch in local repository
    - if ticket is closed
    - if branch's commit are pushed upstream
    - remove local and remote branch
    With --more, include more branch that are not strictly clean, such as 
      closed tickets that have un unmerged commits are asked to the user
    ex: git cleanup

"""

from __future__ import print_function
import sys
import os
import re
import string
import webbrowser
import locale
import time
import json
from pprint import pprint
from subprocess import Popen,PIPE
from tempfile import NamedTemporaryFile

import requests # apt-get install python-requests || pip install requests
import docopt # apt-get install python-docopt || pip install docopt

try:
  import configparser
  config = configparser.ConfigParser()
except ImportError:
  import ConfigParser
  config = ConfigParser.ConfigParser()


## GLOBAL VARIABLES

LIFECYCLES = { "rudder": { "detection": r'\s+remotes/NRM/branches/rudder/',
                           "format": "branches/rudder/{}",
                           "versions": [ "2.10", "2.11", "3.0", "3.1", "master" ]
                         },
               "ncf": { "detection": r'\s+remotes/NRM/v\d\.',
                        "format": "v{}",
                        "versions": [ "0.x", "master" ]
                      },
             }
CONFIG_FILE = "~/.rudder-dev"
HUB_CONFIG_FILE = "~/.config/hub"
REDMINE_ALT_API_URL = "https://redmine.normation.com"
REDMINE_API_URL = "https://www.rudder-project.org/redmine"
REDMINE_API_LIMIT = 100
REDMINE_CLOSED_STATUSES = [5, 6, 16, 11]
REDMINE_META_TRACKERS = [3]

# Keeping old version for reference
#TRACKER_NAME_MAPPING = { 'Bug': 'bug', 'Implementation (development)': 'dev', 'Implementation (integration)': 'int' }
TRACKER_NAME_MAPPING = { 'Bug': 'bug', 'User story': 'ust', 'Architecture': 'arch' }
PENDING_TR_CODE = 3
IN_PROGRESS_CODE = 9
CUSTOM_FIELD_PR = 3


# Filled by get_lifecycle
current_lifecycle = None

###
###  Internal functions
### 

# Run a command in a shell like a script would do
# And inform the user of its execution
def shell(command, comment=None, keep_output=False, fail_exit=True):
  if comment is not None:
    print(comment)
  print(" $ " + command)
  if keep_output:
    process = Popen(command, stdout=PIPE, shell=True)
    output, error = process.communicate()
    print(output)
    retcode = process.poll()
  else: # keep tty management and thus colors
    process = Popen(command, shell=True)
    retcode = process.wait()
    output = None
  if fail_exit and retcode != 0:
    print("*** COMMAND ERROR " + str(retcode))
    if not force:
      exit(1)
  if keep_output:
    return output
  if not fail_exit:
    return retcode
  return None


def parse_ticket_id(ticket_id):
  global REDMINE_TOKEN, REDMINE_API_URL
  if ticket_id.startswith('#'):
    ticket_id = ticket_id[1:]
  internal = False
  match = re.match(r'i(\d+)', ticket_id)
  if match:
    ticket_id = match.group(1)
    REDMINE_TOKEN = REDMINE_ALT_TOKEN
    REDMINE_API_URL = REDMINE_ALT_API_URL
    internal = True
  return (ticket_id, internal)


# Get the version included in a ticket
def get_version(ticket, error_fail=True):
  if 'fixed_version' not in ticket:
    if error_fail:
      print("***** BUG: Can't extract version from #" + str(ticket['id']))
      exit(2)
    else:
      return None
  match = re.search(r'^master$|~alpha\d+|^Initial release$', ticket['fixed_version']['name'])
  if match:
    return 'master'
  else:
    match = re.match(r'\d+\.\w\d*', ticket['fixed_version']['name'])
    if match:
      return match.group(0)
    elif error_fail:
      print("***** BUG: Can't extract version from " + ticket['fixed_version']['name'])
      exit(2)
    else:
      return None
 

# Get informations about a ticket from redmine
def get_ticket_info(ticket_id, internal=False):
  # Find ticket in redmine
  print("Looking for Redmine ticket #" + str(ticket_id) + "... ", end=' ')
  sys.stdout.flush() # to display previous unfinished line
  tickets_req = requests.get(REDMINE_API_URL + "/issues/" + str(ticket_id) + ".json?include=journals", 
                             headers = {'X-Redmine-API-Key': REDMINE_TOKEN, 'Content-Type': 'application/json' })
  ticket = tickets_req.json()['issue'] if tickets_req.status_code == requests.codes.ok else None
  if not ticket:
    print("Not found!")
    print("***** ERROR: ticket not found. Exiting.")
    if not force:
      exit(2)
  else:
    print("Done")
  
  # Check ticket type
  if ticket['tracker'] in REDMINE_META_TRACKERS:
    print("This is a quetsion ticket! You cannot make a pull request on this ticket.")
    print("***** ERROR: This is a question ticket. Exiting.")
    if not force:
      exit(2)

  # Check ticket status
  if ticket['status']['id'] in REDMINE_CLOSED_STATUSES:
    print("This ticket is closed! You cannot make a pull request on this ticket.")
    print("***** ERROR: Closed ticket. Exiting.")
    if not force:
      exit(2)

  if 'fixed_version' not in ticket:
    print("This ticket has no target version! I can't make a branch against its repository.")
    print("***** ERROR: Missing target version. Exiting.")
    if not force:
      exit(2)

  # TODO check assignment ? project ?

  # Get ticket elements
  info = {}
  info['id'] = ticket_id
  info['type'] = ticket['tracker']['name']
  info['name'] = ticket['subject']
  info['version'] = get_version(ticket)
  info['project_id'] = ticket['project']['id']
  info['internal'] = internal
  if 'custom_fields' in ticket:
    for field in ticket['custom_fields']:
      if field['id'] == CUSTOM_FIELD_PR and 'value' in field:
        info['pr'] = field['value']

  # Get ticket's last assignment besides me
  my_id = get_redmine_uid()
  if 'journals' in ticket:
    for journal in ticket['journals']:
      if 'details' in journal:
        for detail in journal['details']:
          if detail['name'] == 'assigned_to_id' and 'old_value' in detail:
            if int(detail['old_value']) != my_id:
              info['last_assignee'] = int(detail['old_value'])

  return info


# Change a ticket version to the closest version available
def update_ticket_version(info, version):
  if REDMINE_ROLE != 'developer':
    print("Cannot change ticket version since you are not a developer, you should change it manualy before calling retarget")
    exit(13)

  # list all versions
  versions = requests.get(REDMINE_API_URL + "/projects/" + str(info['project_id']) + "/versions.json", headers = {'X-Redmine-API-Key': REDMINE_TOKEN } )
  # keep versions that match and that are still open
  valid_versions = [ v for v in versions.json()['versions'] if v['status'] == 'open' and v['name'].startswith(version) ]
  # there should only only, but in doubt keep the last one
  final_version = valid_versions[-1]

  # set the version
  ticket_info = { 'issue': { 'fixed_version_id': final_version['id'] } }
  url = REDMINE_API_URL + "/issues/" + str(info['id']) + ".json"
  ticket_json = json.dumps(ticket_info)
  ret = requests.put(url, headers = {'X-Redmine-API-Key': REDMINE_TOKEN, 'Content-Type': 'application/json' }, data=ticket_json )
  if ret.status_code != 200:
    print("Ticket Update error: " + ret.reason)
    print(ret.text)
    if not force:
      exit(3)
  info['version'] = get_version( { 'fixed_version': final_version } )


# Change ticket state to technical review
def ticket_to_TR(ticket_id, user_id=None, pr_url=None, message=None):
  # Create note content
  note = None
  if pr_url is not None:
    note = "PR " + pr_url
  if message is not None:
    if note is None:
      note = message
    else:
      note += "\n" + message

  if REDMINE_ROLE == 'developer':
    # fill ticket data with developer available content
    ticket_info = { 
            'issue': {
                'status_id': PENDING_TR_CODE,
            }
        }
    if user_id is not None:
      ticket_info['issue']['assigned_to_id'] = user_id
    if note is not None:
      ticket_info['issue']['notes'] = note
    if pr_url is not None:
      ticket_info['issue']['custom_fields'] = [ { 'id': CUSTOM_FIELD_PR, 'value': pr_url } ]

  else:
    # just append the note to ticket
    if note is None:
      return
    else:
      ticket_info = {
              'issue': {
                'notes': note,
              }
          }
  
  # call the api
  url = REDMINE_API_URL + "/issues/" + str(ticket_id) + ".json"
  ticket_json = json.dumps(ticket_info)
  ret = requests.put(url, headers = {'X-Redmine-API-Key': REDMINE_TOKEN, 'Content-Type': 'application/json' }, data=ticket_json )
  if ret.status_code != 200:
    print("Ticket Update error: " + ret.reason)
    print(ret.text)
    if not force:
      exit(3)


# change the ticket state to In progress
def ticket_to_in_progress(ticket_id, message=None):
  # set ticket status to "in progress"
  if REDMINE_TOKEN is not None:
    if REDMINE_ROLE == 'developer':
      print("Changing status of ticket #" + str(ticket_id) + " to \"In progress\"")
      user_id = get_redmine_uid()
      ticket_info = {
              'issue': {
                  'status_id': IN_PROGRESS_CODE,
                  'assigned_to_id': user_id,
              }
      }
      if message is not None:
        ticket_info['issue']['notes'] = message
      url = REDMINE_API_URL + "/issues/" + str(ticket_id) + ".json"
      ticket_json = json.dumps(ticket_info)
      ret = requests.put(url, headers = {'X-Redmine-API-Key': REDMINE_TOKEN, 'Content-Type': 'application/json' }, data=ticket_json )
      if ret.status_code != 200:
        print("Ticket Update error: " + ret.reason)
        print(ret.text)
        if not force:
          exit(3)
    else:
      print("You should update the ticket status here " + REDMINE_API_URL + "/issues/" + str(ticket_id))


# Get Normations users from redmine (users that can review)
def get_normation_users():
  users = requests.get(REDMINE_API_URL + "/users.json?name=normation.com", headers = {'X-Redmine-API-Key': REDMINE_TOKEN } )
  user_list = [ u for u in users.json()['users'] if u['mail'].endswith("normation.com") ]
  return user_list


# get current redmine user
def get_redmine_uid():
  user = requests.get(REDMINE_API_URL + "/users/current.json", headers = {'X-Redmine-API-Key': REDMINE_TOKEN } )
  return user.json()['user']['id']


# Ask for a user using its trigraph
def ask_username(trigraph=None):
  # List Normation users
  users = get_normation_users()
  user_ids = {}
  for user in users:
    tri = user['firstname'][0] + user['lastname'][0] + user['lastname'][1]
    tri = tri.upper()
    user_ids[tri] = user['id']

  # Ask for trigraph of user until found
  if trigraph is not None:
    trigraph = trigraph.upper()
  while trigraph not in user_ids:
    print("Assign to ?")
    for user in users:
      tri = user['firstname'][0] + user['lastname'][0] + user['lastname'][1]
      print("  " + tri + ". " + user['firstname'] + " " + user['lastname'])
    print("Enter trigraph: ", end='')
    sys.stdout.flush() # to display previous unfinished line
    trigraph = sys.stdin.readline().strip().upper()
  return user_ids[trigraph]


# Find a ticket id in a branch name
def ticket_from_branch(branch):
  match = re.match(r'[a-z]+_(i?\d+)/.*', branch)
  if match:
    (ticket_id, internal) = parse_ticket_id(match.group(1))
    return get_ticket_info(ticket_id, internal)
  else:
    print("***** ERROR: This is not a ticket branch: " + branch)
    exit(4)


# Get the current lifecycle
def get_lifecycle():
  global current_lifecycle
  if current_lifecycle is not None:
    return current_lifecycle
  current_lifecycle = "master_only"
  for line in os.popen("git branch --list -a"):
    for lifecycle, data in LIFECYCLES.items():
      if re.match(data["detection"], line):
        current_lifecycle = lifecycle
  return current_lifecycle

  
# Get branch name from version
def branch_from_version(version):
  # detect lifecycle and base ne name on it
  lifecycle = get_lifecycle()
  if lifecycle == "master_only":
    branch_name = "master"
  elif version == "master":
    branch_name = "master"
  else:
    branch_name = LIFECYCLES[lifecycle]['format'].format(version)
  return branch_name


# Calculate branch name from a ticket
def branch_from_ticket(info):
  branchified_ticket_name = re.sub("__+", "_", re.sub("[^" + string.ascii_letters + string.digits + "]", "_", info['name'].strip().lower())).strip("_")
  if info['internal']:
    id = 'i' + str(info['id'])
  else:
    id = str(info['id'])
  branch_name = TRACKER_NAME_MAPPING[info['type']] + "_" + id + "/" + branchified_ticket_name
  return branch_name


# Find an existing branch for a ticket id
def branch_from_ticket_id(ticket_id, internal):
  for line in os.popen("git branch --list"):
    if internal:
      ticket = 'i'+str(ticket_id)
    else:
      ticket = str(ticket_id)
    match = re.search(r'^\*?\s*(\w+_' + ticket + r'/.*?)\n', line)
    if match:
      return match.group(1)
  return None


# Read rudder configuration from ~/.rudder-dev or create a template if none found
def read_configuration():
  global UPSTREAM_REPOSITORY, OWN_REPOSITORY, GITHUB_CMD, REDMINE_TOKEN, REDMINE_ALT_TOKEN, REDMINE_ROLE

  # Detect missing configuration
  if not os.path.isfile(os.path.expanduser(CONFIG_FILE)):
    with open(os.path.expanduser(CONFIG_FILE), 'a') as cfile:
      cfile.write("""[default]
## Uncomment and set your own values
## Name of normation upstream repository on your local git (NRM, origin, ...)
#nrm_upstream = NRM
## Name of personal upstream repository on your local git (BPF, origin, ...)
#own_upstream =
## Command for github cli (uncomment if installed), install from https://github.com/github/hub or https://github.com/github/hub/releases
## Or, on Mac OS, if using Homebrew, brew install hub
#github_cmd = hub
## Redmine personal access token, (create one here http://www.rudder-project.org/redmine/my/account)
#redmine_token = 
#redmine_alt_token = 
## Redmine role level (can be 'reporter' for comment only or 'developer' if you can modify a ticket content)
#redmine_role = reporter
""")
    print(CONFIG_FILE + " doesn't exist !")
    print("I made a sample one, please fill it")
    exit(5)
  
  # Read configuration
  config.read(os.path.expanduser(CONFIG_FILE))
  UPSTREAM_REPOSITORY = get_config("nrm_upstream", "No 'nrm_upstream' entry in " + CONFIG_FILE)
  OWN_REPOSITORY = get_config("own_upstream", "No 'own_upstream' entry in " + CONFIG_FILE)
  GITHUB_CMD = get_config("github_cmd", None)
  REDMINE_TOKEN = get_config("redmine_token", None)
  REDMINE_ALT_TOKEN = get_config("redmine_alt_token", None)
  REDMINE_ROLE = get_config("redmine_role", None)
  if REDMINE_ROLE != 'developer':
    REDMINE_ROLE = 'reporter'


# Get a configuration item from current configuration file
def get_config(item, error):
  try:
    return config.get("default", item)
  except:
    if error is None:
      return None
    else:
      print(error)
      exit(5)


# Get github user as used by the hub command
def get_hub_user():
  if os.path.isfile(os.path.expanduser(HUB_CONFIG_FILE)):
    with open(os.path.expanduser(HUB_CONFIG_FILE)) as f:
      for line in f:
        match = re.search(r'user: (\w+)', line)
        if match:
          return match.group(1)
  print("Github user not found")
  exit(6)


# Get github token as used by the hub command
def get_hub_token():
  if os.path.isfile(os.path.expanduser(HUB_CONFIG_FILE)):
    with open(os.path.expanduser(HUB_CONFIG_FILE)) as f:
      for line in f:
        match = re.search(r'oauth_token: (\w+)', line)
        if match:
          return match.group(1)
  print("Github user not found")
  exit(6)


# Find remote repository name from current directory
def remote_repo():
  value = os.popen("git remote -v").read().strip()
  match = re.search(r'git@github.com:Normation/(.*?).git', value)
  if match:
    return match.group(1)
  print("Can't find remote repository")
  exit(10)


# query github
def github_request(api_url, comment, pr_url=None, post_data=None):
  pr_id = None
  if pr_url is not None:
    # Validate PR url
    match = re.match(r'^http.*/(\d+)(/files|/commits)?$', pr_url)
    if match:
      pr_id = match.group(1)
    else:
      print("Can't find pull-request ID, you should warn the reviewer that you updated the pull-request")
      return False

  # get connection info
  token = get_hub_token()
  repo = remote_repo()
  url = api_url.format(repo=repo, pr_id=pr_id)

  # Say what we are doing
  if comment is not None:
    print(comment)
    print(" > " + url)

  # make query
  if post_data is not None:
    ret = requests.post(url, headers = {'Authorization': 'token ' + token, 'Content-Type': 'application/json' }, data=post_data )
  else:
    ret = requests.get(url, headers = {'Authorization': 'token ' + token, 'Content-Type': 'application/json' })

  # process output
  if ret.status_code < 200 or ret.status_code >= 300:
    print("Github query error " + ret.reason)
    print(ret.text)
    if not force:
      exit(12)

  # return GET result
  if post_data is None:
    return ret.json()
 

# create a new PR
def create_pr(master_branch, ticket_id, title, message):
  if GITHUB_CMD is not None:
    hub_cmd = GITHUB_CMD + " pull-request -F - -b Normation:" + master_branch + " << EOF\n"
    hub_cmd += "Fixes #" + str(ticket_id) + ": " + title + "\n\n"
    hub_cmd += REDMINE_API_URL + "/issues/" + str(ticket_id)
    if message is not None:
      hub_cmd += "\n\n" + message
    hub_cmd += "\nEOF\n"
    return shell(hub_cmd, "Creating PR ... ", True).strip()
  else:
    print("You can now create a pull request from here https://github.com/Normation/<repo-name>/")
    print("And then update the ticket here " + REDMINE_API_URL + "/issues/" + ticket_id)
    print("This tool can automatically create a pull request for you if you install the GitHub CLI tool. See " + CONFIG_FILE + " for details")
    return None


# add a message to a given pull-request on github
def update_pr(pr_url, comment):
  message = "PR updated"
  if comment is not None:
    message += "\n" + comment
  issue = '{ "body": "' + message + '" }'
  url = "https://api.github.com/repos/Normation/{repo}/issues/{pr_id}/comments"
  github_request(url, "Updating PR ...", pr_url, issue)


# close a given pull-request on github
def close_pr(pr_url, comment):
  # Add comment on the closing reason
  issue = '{ "body": "' + comment + '" }'
  url = "https://api.github.com/repos/Normation/{repo}/issues/{pr_id}/comments"
  github_request(url, "Commenting PR ...", pr_url, issue)
  
  # close the PR
  issue = '{ "state": "closed" }'
  url = "https://api.github.com/repos/Normation/{repo}/pulls/{pr_id}"
  github_request(url, "Closing PR ...", pr_url, issue)


# get PR upstream branch
def get_pr_upstream(pr_url):
  url = "https://api.github.com/repos/Normation/{repo}/pulls/{pr_id}"
  pr = github_request(url, None, pr_url)
  return pr['base']['ref']
  

# get PR source informations
def get_pr_source(pr_url):
  url = "https://api.github.com/repos/Normation/{repo}/pulls/{pr_id}"
  pr = github_request(url, None, pr_url)
  return (pr['head']['repo']['git_url'], pr['head']['ref'])


# Commit and push, if needed squash WIP and force push
def commit_push(branch, message, force_amend=False):
  # Fork if needed
  if github_fork():
    # github fork is asynchronous but pretty fast, this should be sufficient
    time.sleep(2)

  wip = os.popen("git log --grep \"^Work in progress\" HEAD^..").read().strip()
  commit_cmd = "git commit"
  if message != '':
    commit_cmd += " -m \"" + message + "\""
  if force_amend or wip != "":
    commit_cmd += " --amend --no-edit"
  shell(commit_cmd, "Commiting")

  # Should we check the need for rebasing before pushing ?

  push_cmd = "git push " + OWN_REPOSITORY + " " + branch
  if force_amend or wip != "":
    push_cmd += " --force"
  shell(push_cmd, "Pushing to " + OWN_REPOSITORY + " ... ")


# insert a line in a file after a regex has matched
def insert_line(filename, regex, text):
  content=[]
  with open(filename, "r+") as fd:
    for line in fd:
      content.append(line)
      if re.match(regex, line):
        content.append(text)
    fd.seek(0)
    fd.truncate()
    fd.writelines(content)


# fetch a branch from a PR given in a ticket
def fetch_branch_from_ticket(ticket):
  # extract ticket info
  (ticket_id, internal) = parse_ticket_id(ticket)
  info = get_ticket_info(ticket_id, internal)
  if 'pr' not in info:
    print("There is no PR in this ticket " + ticket)
    exit(15)

  # look for PR
  (repo, remote_branch) = get_pr_source(info['pr'])

  # fetch remote branch
  branch_name = branch_from_ticket(info)
  shell("git fetch --update-head-ok " + repo + " " + remote_branch + ":" + branch_name, "Fetching branch from remote " + repo)

  return branch_name


def github_fork():
  # we don't need to fork if the remote is known
  remotes = os.popen("git remote show").read()
  if re.match('^'+OWN_REPOSITORY+"\n", remotes, flags=re.MULTILINE):
    return False

  # fork the report if not already forked
  remote_url = ""
  user = get_hub_user()
  remote = remote_repo()
  fork_needed = os.popen("git ls-remote git://github.com/" + user + "/" + remote + ".git HEAD > /dev/null 2>/dev/null; echo $?").read().strip()
  if fork_needed != "0":
    github_request("https://api.github.com/repos/Normation/{repo}/forks", "Forking repository ...", pr_url=None, post_data="")

  # Add the remote repository to the local list
  shell("git remote add " + OWN_REPOSITORY + " git@github.com:" + user + "/" + remote + ".git", "Adding own remote repository")

  # Tell if we forked or not
  return fork_needed != "0"


# Find if there is work in progress and stash it
stashed=False
def stash():
  global stashed
  # count number of change
  change_count = os.popen("git status --porcelain --untracked-files=no | wc -l").read().strip()
  if change_count != "0":
    # stash them
    shell("git stash save --keep-index", "Stashing current work")
    stashed = True


# Find if there is stashed work and unstash it
unstashed=False
def unstash():
  global unstashed

  # get current branch (the global variable may not be accurate in flight)
  branch_process = Popen("git rev-parse --abbrev-ref HEAD", shell=True, stdout=PIPE)
  this_branch = branch_process.stdout.read().strip()

  # do not unstash if we are on an origin branch since you should not work directly on them
  remote_process = Popen("git ls-remote -h " + UPSTREAM_REPOSITORY + " " + this_branch + " | wc -l", shell=True, stdout=PIPE)
  remote_count = remote_process.stdout.read().strip()
  if remote_count != "0":
    return

  # list available stashes
  stash_process = Popen("git stash list", shell=True, stdout=PIPE)
  for line in stash_process.stdout.readlines():
    # parse
    match = re.match(r'^(stash@{.*?}): WIP on (.*?):.*', line)
    if match:
      # match with current branch
      if match.group(2) == this_branch:
        #unstash it
        shell("git stash pop --index '" + match.group(1) + "'" , "Unstashing previous work")
        unstashed=True


# Tell the user if some stash command happened
def stash_info():
  if stashed:
    print("Some work in progress has been found, I stashed it before running the commands, to retrieve it use git stash pop")
  if unstashed:
    print("Previous work in progress has been found in the stash, I unstashed it, to hide it, use git stash save")


###
### MAIN methods 
###   branch, commit, rebase, clone, pull
###

# Create a branch from a ticket id
def create_branch(ticket, base=None):
  global current_branch
  (ticket_id, internal) = parse_ticket_id(ticket)

  existing_branch = branch_from_ticket_id(ticket_id, internal)
  if existing_branch is not None:
    shell("git checkout " + existing_branch, "Found existing branch, checkouting " + existing_branch)
    return

  # get ticket info
  info = get_ticket_info(ticket_id, internal)
  print("* Found " + info['type'] + " #" + str(info['id']) + ": " + info['name'])
  print("* Target: " + info['version'])
  print("* URL: " + REDMINE_API_URL + "/issues/" + str(info['id']))

  # manage the original branch
  if base is not None:
    if re.match(r'^.\d*$', base):
      # fetch base branch
      branch_name = fetch_branch_from_ticket(base)
    else:
      branch_name = base
    # checkout the new branch
    shell("git checkout " + branch_name, "Checkouting the base branch " + branch_name)
  else:
    # Look for release branch and ckeckout its last version
    pull(info['version'])

  # Create the branch
  current_branch = branch_from_ticket(info)
  shell("git checkout -b " + current_branch, "Creating branch " + current_branch)

  # Set ticket's status
  ticket_to_in_progress(ticket_id)

  print("")
  print("# Now you can edit files")
  print("# When you're ready, add them with git add")
  print("# Then type:")
  print(os.path.basename(sys.argv[0]) + " commit")
  print("")


# new version, changelog, commit
def technique(version, message):
  # check current directory
  cwd = os.getcwd()
  match = re.match(r'(.*)/techniques/.*', cwd)
  if not re.match(r'.*/techniques/.*', cwd):
    print("***** ERROR: You must be in a technique directory")
    exit(7)
  basedir = match.group(1)
  script = basedir + '/scripts/technique-files'
  if not os.path.isfile(script):
    print("***** ERROR: You must be in rudder-technique repository")
    exit(7)
  last_version = os.popen(script + " -ld .").read().strip()
  match = re.match(r'\./(\d+\.\d+)', last_version)
  if not match:
    print("***** ERROR: There must be at least one version of the technique in the current directory")
    exit(7)
  last_version = match.group(1)

  # check next version
  match = re.match(r'\d+\.\d+', version)
  if not match:
    print("***** ERROR: Version must be of the form x.y")
    exit(7)
  
  # check branch info
  info = ticket_from_branch(current_branch)

  # new version
  shell("cp -r " + last_version + " " + version, "Creating the version " + version)

  # Deprecate old version
  insert_line(last_version + "/metadata.xml",
              r'\s*<TECHNIQUE name=',
              "  <DEPRECATED>This technique version has been superseded by a new version. It will no longer be available in the next stable version of Rudder. Please upgrade to the latest version.</DEPRECATED>\n")
  shell("git add " + last_version + "/metadata.xml", "Adding deprecated info to old version")

  # changelog
  l = locale.setlocale(locale.LC_ALL, 'C')
  date = time.strftime("%c")
  locale.setlocale(locale.LC_ALL, l)
  user = os.popen("git config --get user.name").read().strip()
  mail = os.popen("git config --get user.email").read().strip()
  changelog = " -- " + user + " <" + mail + "> " + date + "\n"
  changelog += "  * Version " + version + "\n"
  changelog += "  ** " + message + "\n"
  with open(version + "/changelog", "a") as fd:
    fd.write(changelog)

  # commit
  shell("git add " + version, "Adding next version")
  technique = os.path.basename(cwd)
  commit_cmd = "git commit -m \"Refs #" + str(info['id']) + ": Creation of " + technique + " version " + version + " from " + last_version + "\""
  shell(commit_cmd, "Commiting")


# commit, push
def wip():
  # must be on a working branch
  match = re.match(r'[a-z]+_(i?)(\d+)/.*', current_branch)
  if not match:
    print("***** ERROR: This is not a ticket branch: " + branch)
    exit(4)
  commit_push(current_branch, "Work in progress")


# Commit, push, create pull-request, update ticket
def commit(trigraph=None, message=None):
  info = ticket_from_branch(current_branch)
  master_branch = branch_from_version(info['version'])

  # commit and push
  commit_push(current_branch, "Fixes #" + str(info['id']) + ": " + info['name'].replace("\"", "\\\""))

  # create PR
  pr_url = create_pr(master_branch, info['id'], info['name'].replace("\"", "\\\""), message)

  # update ticket
  if REDMINE_TOKEN is not None and pr_url is not None:
    if REDMINE_ROLE == 'developer':
      user = ask_username(trigraph)
    else:
      user = None
    print("Updating ticket #" + str(info['id']))
    ticket_to_TR(info['id'], user, pr_url, message)
    print("Ticket updated: " + REDMINE_API_URL + "/issues/" + info['id'])
  else:
    print("You can now update the ticket here " + REDMINE_API_URL + "/issues/" + info['id'])


# amend commit, push -f, comment PR
def amend(comment=None):
  info = ticket_from_branch(current_branch)
  
  # commit over last commit and push
  commit_push(current_branch, '', True)

  # reassign ticket
  if 'last_assignee' in info:
    ticket_to_TR(info['id'], info['last_assignee'])

  # Message on PR if there is one
  if info['pr'] != '':
    update_pr(info['pr'], comment)
    print("Done, you can see the PR here: " + info['pr']) 


# rebase, push -f, comment PR
def rebase(comment=None, base=None):
  info = ticket_from_branch(current_branch)

  # fetch before rebasing
  if base is not None:
    if re.match(r'^.\d*$', base):
      # base branch from ticket id
      branch_name = fetch_branch_from_ticket(base)
    else:
      # base branch from branch name
      branch_name = base
  else:
    # base branch from upstream repository
    shell("git fetch " + UPSTREAM_REPOSITORY, "Fetching upstream " + UPSTREAM_REPOSITORY)
    origin_branch = branch_from_version(info['version'])
    branch_name = UPSTREAM_REPOSITORY + "/" + origin_branch

  # First rebase without commits from source branch
  # This is necessary because we may have modified the original commit and force pushed it
  with NamedTemporaryFile(delete=False) as tmpscript:
    tmpscript.write("""#!/bin/sh
perl -i -ne "print unless s/^pick \w+ Fixes #(?!%(ticket)s)//" "$1"
""" % { "ticket": info['id']})
    os.system("chmod +x " + tmpscript.name)
    # If it fails, let the interactive rebase try to fix it
    shell("EDITOR=" + tmpscript.name + " git rebase -i " + branch_name, "First rebase to remove parent commits", fail_exit=False)
    os.unlink(tmpscript.name)


  # Then interactive rebase
  shell("git rebase -i " + branch_name, "Rebasing")

  # if OK: continue
  shell("git push --force " + OWN_REPOSITORY + " " + current_branch)

  # reassign ticket
  if 'last_assignee' in info:
    ticket_to_TR(info['id'], info['last_assignee'])

  # Message on PR if there is one
  if info['pr'] != '':
    update_pr(info['pr'], comment)
    print("Done, you can see the PR here: " + info['pr'])


# close PR, rebase, push -f, create PR, update ticket
def retarget(version=None):
  info = ticket_from_branch(current_branch)

  # update ticket if required
  if version is not None:
    print("Changing target version in the ticket to " + version)
    update_ticket_version(info, version)
    print("New version " + info['version'])

  ticket_branch = branch_from_version(info['version'])

  upstream_branch = get_pr_upstream(info['pr'])
  if ticket_branch == upstream_branch:
    print("Ticket branch and PR branch match (" + upstream_branch + "), no need to retarget!")
    return

  # fetch before rebasing
  shell("git fetch " + UPSTREAM_REPOSITORY, "Fetching upstream " + UPSTREAM_REPOSITORY)

  # interactive rebase
  shell("git rebase -i " + UPSTREAM_REPOSITORY + "/" + ticket_branch, "Rebasing")

  # if OK: continue
  shell("git push --force " + OWN_REPOSITORY + " " + current_branch)

  # create new PR 
  pr_url = create_pr(ticket_branch, info['id'], info['name'].replace("\"", "\\\""), "Replacing previous PR: " +  info['pr'])

  # close old PR
  close_pr(info['pr'], "PR replaced by " + pr_url)

  # update ticket
  user = None
  if 'last_assignee' in info:
    user = info['last_assignee']
  ticket_to_TR(info['id'], user, pr_url)


# ckeckout version, pull
def pull(version=None):
  global current_branch
  if version is not None:
    branch = branch_from_version(version)

    # branch if needed
    branch_status = os.popen("git branch --list " + branch).read().strip()
    if branch_status == "":
      shell("git fetch " + UPSTREAM_REPOSITORY, "Local branch doesn't exist, fetching from " + UPSTREAM_REPOSITORY)
      remote_branch_status = os.popen("git branch --list --remote " + UPSTREAM_REPOSITORY + "/" + branch)
      if remote_branch_status == "":
        print("No such branch on " + UPSTREAM_REPOSITORY + ": " + branch + ", Aborting ...")
        exit(8)
      shell("git branch --track " + branch + " " + UPSTREAM_REPOSITORY + "/" + branch, "Creating local branch")

    # checkout if needed
    if branch != current_branch:
      shell("git checkout " + branch, "Checkouting " + branch)
    current_branch = branch

  # Pull
  branch_detail = os.popen("git rev-parse --abbrev-ref --symbolic-full-name @{u}").read().strip()
  if re.match(UPSTREAM_REPOSITORY + '/.*', branch_detail):
    shell("git pull --ff-only", "Pulling on " + branch_detail)
  else:
    print("Your branch is not based on the same " + UPSTREAM_REPOSITORY + " branch")
    exit(8)


# clone from NRM, fork, add OWN, set-upstream
def clone(name, fork=False):
  shell("git clone --origin " + UPSTREAM_REPOSITORY + " git@github.com:Normation/" + name + ".git", "Cloning Normation repository")
  if fork:
    os.chdir(name)
    github_fork()


# takevover a ticket with an existing PR
def takeover(ticket):
  global current_branch

  existing_branch = branch_from_ticket_id(ticket_id, internal)
  if existing_branch is not None:
    print("***** ERROR: Can't take over a ticket with a matching branch already existing in your repository")
    exit(12)

  # fetch base branch
  current_branch = fetch_branch_from_ticket(ticket)

  # checkout the new branch
  shell("git checkout " + current_branch, "Checkouting the base branch " + current_branch)

  # same workflow as work in progress (but with an existing commit)
  commit_push(current_branch, "Work in progress", True)

  # Set ticket's status
  ticket_to_in_progress(ticket_id, "I'm taking over this ticket!")

  print("")
  print("# Now you can edit files")
  print("# When you're ready, add them with git add")
  print("# Then type:")
  print(os.path.basename(sys.argv[0]) + " commit")
  print("")


# Merge remote branch
def merge(old, new, strategy=None, automatic=False):
  pull(old)
  pull(new)
  opts = ""
  if strategy is not None:
    opts = " -s " + strategy
  if automatic:
    opts += " --no-edit "
  shell("git merge " + branch_from_version(old) + opts, "Merging " + old + " into " + new)
  shell("git push " + UPSTREAM_REPOSITORY + " " + branch_from_version(new))


# Merge remote branch automatically guessing the next one
def merge_to_next(old, strategy=None, automatic=False):
  lifecycle = get_lifecycle()
  if lifecycle not in LIFECYCLES:
    print("I don't know how to merge a repository based on a '" + lifecycle + "' lifecycle")
    exit(1)
  all_versions = LIFECYCLES[lifecycle]['versions']
  new = None
  for idx, version in enumerate(all_versions):
    if old == version:
      if idx < len(all_versions)-1:
        new = all_versions[idx+1]
  if new is None:
    print("Don't know how to merge " + old)
    exit(9)
  merge(old, new, strategy, automatic)


# Merge all breanches to next one
def merge_all(strategy=None, automatic=False):
  lifecycle = get_lifecycle()
  if lifecycle not in LIFECYCLES:
    print("I don't know how to merge a repository based on a '" + lifecycle + "' lifecycle")
    exit(1)
  for branch in LIFECYCLES[lifecycle]['versions'][:-1]:
    merge_to_next(branch, strategy, automatic)


# Run a command on all branches
def find(command):
  lifecycle = get_lifecycle()
  if lifecycle not in LIFECYCLES:
    print("I don't know how to look for branches in a repository based on a '" + lifecycle + "' lifecycle")
    exit(1)
  status = {}
  for branch in LIFECYCLES[lifecycle]['versions']:
    pull(branch)
    status[branch] = shell(command, fail_exit=False)
  print("---")
  for branch in LIFECYCLES[lifecycle]['versions']:
    ok = "OK" if status[branch] == 0 else "ERR"
    print("%6s: %3s (%d)" % (branch, ok, status[branch]))
  print("---")


# cleanup branches
def cleanup(more=False, dry=False):
  shell("git fetch " + UPSTREAM_REPOSITORY, "Fetching " + UPSTREAM_REPOSITORY,)
  pull('master') # necessary to avoid removal errors
  branch_process = Popen("git branch --no-color --no-column", shell=True, stdout=PIPE)
  branch_list = branch_process.stdout.read()
  for branch in branch_list.split('\n'):
    m = re.match(r'^\s*((?:bug|dev|int|impl|ust|UST)_(\d+)/.*)\s*$', branch)
    if m:
      branch=m.group(1)
      ticket_id = m.group(2)
      print("#" + ticket_id + ": ", end='')
      tickets_req = requests.get(REDMINE_API_URL + "/issues/" + str(ticket_id) + ".json", headers = {'X-Redmine-API-Key': REDMINE_TOKEN, 'Content-Type': 'application/json' })
      remove = False

      # guess if we should remove the branch
      if tickets_req.status_code == requests.codes.ok:
        ticket = tickets_req.json()['issue']
        # The ticket is closed -> probably
        if ticket['status']['id'] in REDMINE_CLOSED_STATUSES:
          print("ticket closed, ", end='')
          version = get_version(ticket, False)
          should_ask = False
          if version is not None:
            upstream = UPSTREAM_REPOSITORY + '/' + branch_from_version(version)
            cherry_process = Popen("git cherry " + upstream + " " + branch + " 2>/dev/null", shell=True, stdout=PIPE)
            cherry_list = cherry_process.stdout.read()
            if cherry_process.wait() == 0 and cherry_list == "":
              # Everything is merged -> YES
              print("commits merged upstream, ", end='')
              remove = True
            else:
              # Some commits mays not have been merged -> Ask the user
              print("some commits not merged upstream, ", end='')
              should_ask = True
          else:
            # Can't find upstream branch -> ask the user
            print("can't check upstream branch from ticket, ", end='')
            should_ask = True
          if more and should_ask:
            print(REDMINE_API_URL + "/issues/" + ticket_id)
            print("Do you want to remove it ? [y/N]", end='')
            sys.stdout.flush() # to display previous unfinished line
            answer = sys.stdin.readline().strip().upper()
            if answer.upper() == "Y":
              remove = True
        # The ticket is open -> NO
      
      if remove:
        print("removing: " + branch)
        if not dry:
          shell("git branch -d " + branch, "Deleting local " + branch)
          shell("git push " + OWN_REPOSITORY + " --delete " + branch, "Deleting remote " + branch)
      else:
        print("keeping: " + branch)


# Main loop
if __name__ == "__main__":
  arguments = docopt.docopt(__doc__)
  read_configuration()

  # smart argument
  smart = arguments['<smart_arg>']
  if smart:
    if re.match(r'^i?\d{2,5}$', smart):
      arguments['branch'] = True
      arguments['<ticket_id>'] = smart
    elif re.match(r'^\d\.(\d+|x)$|^master$', smart):
      arguments['pull'] = True
      arguments['<branch>'] = smart
    elif re.match(r'^[A-Z]{3}$', smart):
      arguments['commit'] = True
      arguments['<trigraph>'] = smart
    else:
      print("Error, unknown <smartarg> " + smart)
      exit(10)

  # Force argument is a global variables
  force = arguments['-f'] or arguments['--force']

  if not arguments['clone']: # this is the only exception
    # check repository and get common info
    branch_process = Popen("git rev-parse --abbrev-ref HEAD", shell=True, stdout=PIPE)
    current_branch = branch_process.stdout.read().strip()
    if branch_process.wait() != 0:
      print("***** ERROR: Unable to get the current git branch name, this directory is probably not a git repository")
      exit(11)

  # standard arguments
  if arguments['clone']:
    clone(arguments['<repository>'], arguments['--fork'])
  elif arguments['pull']:
    stash()
    pull(arguments['<branch>'])
    unstash()
    stash_info()
  elif arguments['branch']:
    stash()
    create_branch(arguments['<ticket_id>'], arguments['--base'])
    unstash()
    stash_info()
  elif arguments['technique']:
    technique(arguments['<version>'], arguments['<comment>'])
  elif arguments['wip']:
    wip()
  elif arguments['commit']:
    commit(arguments['<trigraph>'], arguments['<PR_comment>'])
  elif arguments['amend']:
    amend(arguments['<PR_comment>'])
  elif arguments['rebase']:
    rebase(arguments['<PR_comment>'], arguments['--base'])
  elif arguments['retarget']:
    retarget(arguments['<target_version>'])
  elif arguments['takeover']:
    takeover(arguments['<ticket_id>'])
  elif arguments['merge']:
    stash()
    before_merge_branch = current_branch
    if arguments['all']:
      merge_all(arguments['<strategy>'], arguments['-a'] or arguments['--automatic'])
    else:
      if arguments['<next_branch>'] is None:
        merge_to_next(arguments['<first_branch>'], arguments['<strategy>'], arguments['-a'] or arguments['--automatic'])
      else:
        merge(arguments['<first_branch>'], arguments['<next_branch>'], arguments['<strategy>'], arguments['-a'] or arguments['--automatic'])
    shell("git checkout " + before_merge_branch, "Going back to the branch we were before merge")
    unstash()
  elif arguments['find']:
    find(arguments['<command>'])
  elif arguments['cleanup']:
    cleanup(arguments['--more'], arguments['-n'] or arguments['--dry-run'])

